<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">@media screen { h1,h2,h3,h4,h5,p,a,br,li,td, .underline {font-family:Arial, Helvetica, sans-serif;text-align:justify} body {font-size:11pt;line-height:1.3em} h1 {font-size:18pt} h2 {font-size:15pt} h3 {font-size:13pt} h4 {font-size:12pt} h5 {font-size:11pt} hr {text-align:center;height:1px;border:none;background:black} ol,ul,p,table {margin-left:3em;margin-right:3em} a {text-decoration:none} a:hover {text-decoration:underline} img {} .defword {width:25%} .defexplain {} .defexplain p {padding:0em;margin:0em} .deftablepara {} .deftable {width:85%;padding-left:1em;border-style:none;vertical-align:top} .deftable td {text-align:left;vertical-align:top} .deftablefaq {border-style:solid;border-width:thin} .stdtable {border:1px solid;background:black} .stdtable th {padding:0.5em;background:#EEEEEE;font-family:Arial, Helvetica, sans-serif;font-weight:bold;text-align:center} .stdtable td {padding:0.5em;background:white;text-align:left;vertical-align:top} .end {font-size:8pt} .example {margin-left:3em;margin-right:3em;border:1px solid;padding:1em;background-color:#EEEEEE} .header {margin-left:3em;margin-right:3em;border:1px solid;padding:1em;background-color:#FFFFEE} .indented {margin-left: 50px} .litable {text-align:left} .new {border-right:10px solid;padding-right:10px;font-family:Arial} .note {margin:0.5em 3em 0.5em 3em;border:1px solid;padding:0em;background-color:#F0F0A0} .note .title {font-family:sans-serif;font-weight:bold;margin:0.5em} .note .message {margin:0.5em 1.5em 0.5em 1.5em;padding:0em} .note .message p {padding:0em;margin:1em 0em 1em 0em} .reference {} .caption {font-size:10pt;text-align:center;font-style:italic} .todolist {padding:0.5em;font-size:10pt} .todolist p {margin:0em 3em 0em 3em} .todo {margin:1em 3em 1em 3em;padding:0.5em;border:solid 2px black;background:#FFAAAA;font-size:8pt} .todo p {margin:0.2em 1em 0.2em 1em} .inline {margin:0.5em 3em 0.5em 3em;border:solid 1px;padding:0em;background-color:#EEEEEE} .inline .title {font-family:sans-serif;font-weight:bold;margin:0.5em} .inline .elements {font-size:10pt;margin:0em 0em 0.5em 0em;padding:0em 1em 0em 1em} .inline .elements p {display:inline-table;margin:0.25em 0.5em 0.25em 0.5em} .tocindent {margin-left: 2em} .top {font-size:8pt;text-align:right} .underline {text-decoration:underline} } @media print { h1,h2,h3,h4,h5,p,a,br,li, #underline {font-family:Arial;text-align:justify;orphans:5;widows:5} p,li,td {font-size:10pt} ul,ol {page-break-after:avoid;orphans:5;widows:5} }</style><title>R3-GUI Getting Started</title></head><body onload="window.location.hash = window.location.hash"><a id="top" name="top"></a><h2>R3-GUI Getting Started</h2><pre class="header"><strong>Author: Robert M. MÃ¼nch, Saphirion AG
Date: 19-Jan-2013
Version: $Id$</strong></pre><hr /><h2>Contents</h2><div class="tocindent"><a href="#sect1"><strong>1. Introduction</strong></a><br /><div class="tocindent"><a href="#sect1.1"><strong>1.1  Where does R3-GUI fit with respect to the other GUI libs?</strong></a><br /><a href="#sect1.2"><strong>1.2  Available Documentation</strong></a><br /><a href="#sect1.3"><strong>1.3  Getting Ready</strong></a><br /></div><a href="#sect2"><strong>2.  Minimal Example</strong></a><br /><div class="tocindent"><a href="#sect2.1"><strong>2.1  Summary</strong></a><br /></div><a href="#sect3"><strong>3.  How do things fit together?</strong></a><br /><a href="#sect4"><strong>4.  What to read next?</strong></a><br /></div><div class="note"><div class="message"><p>The docs are work in progress.</p></div></div><h2><a id="sect1" name="sect1">1. Introduction</a></h2><p>R3-GUI is a framework for building GUI applications with Rebol-3.</p><p>R3-GUI is inspired by the Rebol-2 GUI framework VID in terms of ease of use and using a dialect to specify your GUI.</p><p>R3-GUI is designed for real-world applications and can be used to create simple tests up to even big commercial applications.</p><h3><a id="sect1.1" name="sect1.1">1.1  Where does R3-GUI fit with respect to the other GUI libs?</a></h3><p>R3-GUI is not compatible (anymore) with the GUI done by Carl Sassenrath for Rebol 3 in the past. We forked R3-GUI and extended &amp; changed it. This was due to some limitations we hit and to some design decisions that we think are not fitting our goal to make enterprise applications with R3-GUI.</p><h3><a id="sect1.2" name="sect1.2">1.2  Available Documentation</a></h3><p>Different aspects of R3-GUI are documented. Some high-level stuff but although some very deep low-level stuff. The documentation is still in an early stage. We are working one it.</p><p>We provide some older documentation as well. This documentation is based on the former GUI framework (before our fork) and still give some hintsight. Nevertheless, most examples etc. won't work with our version.</p><p>We are going to clean-up this situation over time.</p><h3><a id="sect1.3" name="sect1.3">1.3  Getting Ready</a></h3><p>R3-GUI is not part of the R3 interpreter. The R3 interpreter just contains the underlaying things like the graphics engine and basic graphic building blocks.</p><p>To use R3-GUI you first have to load it. This can be done by downloading R3-GUI to your local directory. An other option is to use Saphirion's latest release and have it downloaded from our web-site. To do this use:</p><pre class="example">load-gui</pre><p>Saphirion's R3 version has the URL to the R3-GUI source code hard-coded into R3, so you don't have to care.</p><div class="note"><div class="message"><p>At the moment you can load only one version. We are going to add more fine grain options so that you can load the latest, stable, or a specific version using the load-gui command.</p></div></div><div class="top">[ <a href="#top">back to top</a> ]</div><hr /><h2><a id="sect2" name="sect2">2.  Minimal Example</a></h2><p>The following example creates a window that displays a text and has a button to close the window.</p><pre class="example">view [
    text &quot;Example window.&quot;
    button &quot;Close&quot; on-action [close-window face]
]</pre><p>Let's walk through the different parts of the code.</p><pre class="example">view &lt;layout block&gt;</pre><p>The VIEW function displays a window with a content that is specfied by a so called layout block. The layout block is the part that is written in R3-GUI language. In this block you specify how the GUI should be build and act.</p><p>Hence, the layout block is a classical Rebol dialect. A specialized domain specific language to describe GUIs.</p><p>The next two lines already use two widgets, which are called styles in the Rebol world. These are provided and implemented by the R3-GUI code you loaded.</p><pre class="example">text &lt;string&gt;
button &lt;caption&gt; on-action &lt;action-block&gt;</pre><p>TEXT obviously shows the text given by the string. And BUTTON shows a button. So far pretty easy.</p><p>The interesting part is how we define an action. Something that should be executed when the user uses the widget. This is done by specifying an ON-ACTION action-block. R3-GUI knows for each widget, when the on-action should be executed. This is defined by the person who implemented the widget. Depending on the widget an ON-ACTION can be executed on different user actions. For the button this is the case, when you press the button. For a complex widget, this might be something totally different.</p><p>Let's take a look at the action itself.</p><pre class="example">on-action [close-window face]</pre><p>The CLOSE-WINDOW function is quite easy to understand. But what's this FACE word? Where does it come from? When R3-GUI executes the action-block it actually does this:</p><pre class="example">do-actor face 'on-action any [arg-value get-face face]</pre><p>Here the FACE word is actually our BUTTON. So, it uses our button object, looks up the ON-ACTION actor and executes the found code like a function call. And, as for normal functions, the function is called with some parameters. In our case with FACE which refers to our button widget. And since you can access function parameters in the function code, you can of course use the FACE word to get access to the button object.</p><p>So, there are some implicit words you can use. These are always the same for all widgets.</p><p>Hmm, but how do you close the window of the BUTTON widget? Well, CLOSE-WINDOW doesn't close the windows specified by FACE but it's parent. Which is, in our case, the main window. Hence, the program terminates.</p><h3><a id="sect2.1" name="sect2.1">2.1  Summary</a></h3><p>You see that it's quite easy to do GUIs with R3-GUI. You need to know a couple of concepts and that's it. Here is a list of things to remember:</p><ol><li>Use VIEW to transform the R3-GUI dialect into some internal form and display it.</li><li>All code that should be executed because of an action by the user is put in an ON-ACTIOn action-block. This is a <strong>major</strong> difference to older R3-GUI implementations where the action-block wasn't preceded by the ON-ACTION word.</li><li>You can access implicit words inside the action-block. One that is always available is FACE which referes to the widget in which context the action is executed.</li></ol><div class="top">[ <a href="#top">back to top</a> ]</div><hr /><h2><a id="sect3" name="sect3">3.  How do things fit together?</a></h2><p>Since R3-GUI is a bit different than normal GUI libraries you might know from the C, Java, etc. world, let's see how things fit together.</p><p>You already learned that the Rebol widgets are called styles. These are prototype definitions, that define default values for most attributes of a widget. Something like a class.</p><p>From such styles, you create a specific FACE that uses a STYLE as base. The FACE is the actual concrete widget on the screen. You can change all values of its attributes. A FACE object offers a lot of information you can inspect.</p><p>A group of faces is managed through a layout. Layouts are collections of faces used for specific parts of a user interface. You specify the layout by using special layout words in the layout-block of the VIEW function.</p><p>R3-GUI system has been designed to make layouts very easy to create, debug, and maintain. One of the main goals was for simple GUI definitions to be able to create a wide range of simple, predictable layouts, but also to allow more sophisticated and elaborate results to be produced using the same set of basic rules.</p><p>Basically, layouts provide a way to:</p><ol><li>Group a number of faces together</li><li>Arrange faces into a desired layout</li><li>Display a 2D layer, with background or other effects</li><li>Update and resize those faces when events occur</li></ol><div class="top">[ <a href="#top">back to top</a> ]</div><hr /><h2><a id="sect4" name="sect4">4.  What to read next?</a></h2><p>To get a good understanding, we suggest that you read things in the following order:</p><ol><li>FACES to understand the basic building blocks and how these looks like.</li><li>LAYOUTS to understand how you can build GUIs consisting of many widgets and how these are managed.</li><li>ACTORS bring life to your GUI. This is where all the interaction comes from.</li><li>STYLES to understand how new widgets can be defined.</li></ol><p>END OF DOCUMENT</p><div class="top">[ <a href="#top">back to top</a> ]</div><hr /><p class="end">Document formatter copyright <a href="http://www.robertmuench.de">Robert M. M&uuml;nch</a>. All Rights Reserved.<br />XHTML 1.0 Transitional formatted with Make-Doc-Pro Version:1.3.0 on 20-Jan-2013 at 1:27:16</p></body></html>